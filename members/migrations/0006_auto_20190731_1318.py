# Generated by Django 2.2.3 on 2019-07-31 11:18
# This migration will be used to convert payments so charges and refunds are on
# separate lines rather than the same line.

from django.db import migrations

# This is a copy of the payment table. The thought is that we make sure to
# change all relevant code so it use the new database and make a migration where
# we delete the old database and change this tables name to Payment

def convert_payments(apps, schema_editor):
    Payment = apps.get_model("members", "Payment")
    tempPay = apps.get_model("members", "NewPaymentTemp")
    actPar = apps.get_model("members", "ActivityParticipant")
    cur_id = 1
    for pay in Payment.objects.all():
        # We go through each object making sure it is not refunded or cancelled
        # If it is, we need to create another transaction for that. Before starting
        # we always note the original primary key in the external_id field so we can
        # adjust quickpays id's afterwards
        # In all cases create transaction
        if pay.pk > cur_id:
            new_pay = tempPay.objects.create(
                pk = pay.pk,
                external_id = pay.pk,
                added = pay.added,
                payment_type = pay.payment_type,
                person = pay.person,
                body_text = pay.body_text,
                amount_ore = pay.amount_ore,
                confirmed_dtm = pay.confirmed_dtm,
                status = "NEW",
                rejected_dtm = pay.rejected_dtm,
                rejected_message = pay.rejected_message,
            )
            cur_id = pay.pk
        else:
            new_pay = tempPay.objects.create(
                external_id = pay.pk,
                added = pay.added,
                payment_type = pay.payment_type,
                person = pay.person,
                body_text = pay.body_text,
                amount_ore = pay.amount_ore,
                confirmed_dtm = pay.confirmed_dtm,
                status = "NEW",
                rejected_dtm = pay.rejected_dtm,
                rejected_message = pay.rejected_message,
            )
            cur_id += 1
        if pay.activityparticipant is not None:
            act_par = actPar.objects.get(pk=pay.activityparticipant.pk)
            act_par.payment = new_pay
            act_par.save()
        if pay.refunded_dtm is not None:
            # Transaction is refunded
            # Create refund transaction
            new_refund = tempPay.objects.create(
                external_id = pay.pk,
                added = pay.refunded_dtm,
                payment_type = pay.payment_type,
                person = pay.person,
                body_text = pay.body_text,
                amount_ore = (pay.amount_ore*-1),
                confirmed_dtm = pay.refunded_dtm,
                status = "REFUNDED",
                rejected_dtm = pay.rejected_dtm,
                rejected_message = pay.rejected_message,
            )

        if pay.cancelled_dtm is not None:
            # Transaction has been cancelled.
            # Check it has not been refunded.
            # If it has not been refunded, create cancel transaction.
            if pay.refunded_dtm is None:
                new_cancel = tempPay.objects.create(
                    external_id = pay.pk,
                    added = pay.cancelled_dtm,
                    payment_type = pay.payment_type,
                    person = pay.person,
                    body_text = pay.body_text,
                    amount_ore = (pay.amount_ore*-1),
                    confirmed_dtm = pay.cancelled_dtm,
                    status = "CANCELLED",
                    rejected_dtm = pay.rejected_dtm,
                    rejected_message = pay.rejected_message,
                )

def reverse_convert_payments(apps, schema_editor):
    Payment = apps.get_model("members", "Payment")
    tempPay = apps.get_model("members", "NewPaymentTemp")
    actPar = apps.get_model("members", "ActivityParticipant")
    for temppayment in tempPay.objects.all():
        # Reverse way
        # Identify what type it is
        # If it's NEW, then create payment with old pk
        # If it's REFUNDED or CANCELLED set refunded_dtm
        # or cancelled_dtm on the payment with the correct pk.
        if temppayment.status == "NEW":
            new_pay = Payment.objects.create(
                pk = temppayment.external_id,
                added = temppayment.added,
                payment_type = temppayment.payment_type,
                person = temppayment.person,
                family = temppayment.person.family,
                body_text = temppayment.body_text,
                amount_ore = temppayment.amount_ore,
                confirmed_dtm = temppayment.confirmed_dtm,
                cancelled_dtm = None,
                refunded_dtm = None,
                rejected_dtm = temppayment.rejected_dtm,
                rejected_message = temppayment.rejected_message,
            )
            try:
                act_par = actPar.objects.get(payment=temppayment)
                act_par.payment = None
                act_par.save()
            except Exception:
                pass
        elif temppayment.status == "REFUNDED":
            refund_trans = Payment.objects.get(pk=temppayment.external_id)
            refund_trans.refunded_dtm = temppayment.confirmed_dtm
            refund_trans.save()
        elif temppayment.status == "CANCELLED":
            cancel_trans = Payment.objects.get(pk=temppayment.external_id)
            cancel_trans.cancelled_dtm = temppayment.confirmed_dtm
            cancel_trans.save()

class Migration(migrations.Migration):
    dependencies = [
        ('members', '0005_auto_20190731_1407'),
    ]

    operations = [
        migrations.RunPython(convert_payments, reverse_convert_payments)
    ]